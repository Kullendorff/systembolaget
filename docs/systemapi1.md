En strategisk och teknisk guide för att bygga ett AI-drivet vinutforskningsverktyg med Systembolagets data och Claude DesktopIntroduktionSyfte och visionDenna rapport syftar till att tillhandahålla en uttömmande strategisk och teknisk plan för att förverkliga visionen om ett sofistikerat, AI-drivet verktyg för vinutforskning. Målet är att omvandla en passion för vin till ett kraftfullt, personligt verktyg som kan assistera i att navigera Systembolagets omfattande sortiment. Projektet är inte bara ambitiöst utan också fullt genomförbart med de metoder och tekniker som presenteras här.Den centrala utmaningen och möjlighetenKärnan i detta projekt är att hantera en grundläggande utmaning: Systembolaget har officiellt upphört med sitt publika API för produktinformation. Denna medvetna policyförändring, driven av Systembolagets folkhälsouppdrag, har stängt dörren för direkt, sanktionerad programmatisk åtkomst till deras sortimentsdata. Detta skulle kunna ses som ett oöverstigligt hinder, men i stället har det gett upphov till en betydande möjlighet. Ett engagerat och tekniskt kunnigt community har utvecklat robusta och dataspäckade alternativ som kringgår denna begränsning. Denna rapport kommer att navigera i detta landskap av community-drivna lösningar för att erbjuda en tydlig och hållbar väg framåt.Arkitektonisk vägkartaFör att koppla denna värdefulla data till den avancerade språkförståelsen hos en AI-assistent som Claude, kommer två primära arkitektoniska vägar att utforskas i detalj. Varje väg representerar en distinkt filosofi för systemintegration, med sina egna styrkor och komplexitetsnivåer.En traditionell webbtjänst: Denna metod innebär att bygga en liten, personlig webbserver som exponerar vindata via ett REST API. Claude skulle sedan interagera med detta API genom sin standardiserade, internetbaserade "Tool Use"-funktionalitet (även känd som "Function Calling").En djupt integrerad lokal server via Model Context Protocol (MCP): Denna mer avancerade väg är skräddarsydd för användarens specifika intresse av Claude Desktop. Den innebär att bygga en lokal server som körs direkt på användarens dator och kommunicerar sömlöst och säkert med Claude Desktop via det specialiserade Model Context Protocol.Rapportens strukturDenna guide är strukturerad för att systematiskt leda från dataanalys till teknisk implementering och strategiska rekommendationer. Rapporten inleds med en grundlig undersökning av det nuvarande landskapet för Systembolagets produktdata. Därefter presenteras och detaljeras de två arkitektoniska vägarna, komplett med konceptuella implementeringsguider. Slutligen genomförs en jämförande analys som kulminerar i en välgrundad rekommendation för den mest lämpliga vägen framåt.Sektion 1: Landskapet för Systembolagets produktdata: Från officiell stängning till community-driven innovation1.1 Det officiella API:et: En stängd dörrFör att förstå de nuvarande möjligheterna är det avgörande att först förstå historien bakom Systembolagets officiella API. Tidigare erbjöd Systembolaget ett öppet API som gav utvecklare tillgång till detaljerad produktinformation. Detta API stängdes dock ner för produktdata i september 2022.Anledningen var en fundamental policykonflikt. Systembolaget identifierade att deras produktdata användes av kommersiella aktörer på ett sätt som stred mot deras kärnuppdrag och svensk alkoholpolitik. Specifikt användes informationen för att driva försäljning av alkoholdrycker, vilket går emot Systembolagets mål att informera om risker och sälja med ansvar, utan vinstintresse. Denna kontext är fundamental, eftersom den förklarar varför en direkt, officiellt sanktionerad åtkomst till produktdata inte längre är ett alternativ och sannolikt inte kommer att bli det i framtiden.Det som återstår av de officiella API:erna är funktionalitet som inte direkt rör enskilda produkter. Det är fortfarande möjligt att programmatiskt hämta information om butiker, ombud och leverantörer. Även om detta är användbart i andra sammanhang, är det otillräckligt för det detaljerade, produktfokuserade verktyg som efterfrågas.1.2 Community-drivna alternativ: Ett öppet fönsterNedstängningen av det officiella API:et skapade inte ett datavakuum. Istället stimulerade det utvecklarcommunityt att skapa egna lösningar för att bibehålla åtkomsten till den offentligt tillgängliga, men programmatiskt begränsade, produktinformationen. Två huvudsakliga strategier har utkristalliserat sig, var och en med sina egna tekniska egenskaper och risknivåer.Strategi 1: Statiska datarepositorierDenna strategi är den mest robusta och vanligt förekommande. Den bygger på att automatiserade skript (ofta kallade "bots") regelbundet skrapar eller laddar ner hela Systembolagets produktsortiment från deras webbplats. Denna data konsolideras sedan och lagras i ett offentligt tillgängligt arkiv, vanligtvis på plattformar som GitHub, i form av stora, statiska JSON-filer.Exempel A: AlexGustafsson/systembolaget-api-data: Detta är ett utmärkt exempel på en väletablerad datakälla. Repositoriet fungerar som en uppdaterad spegel av Systembolagets sortiment. Datan samlas in med hjälp av ett tillhörande Go-baserat verktyg, systembolaget-api, och uppdateras automatiskt via ett skript (bot.sh). Detta skapar en pålitlig, om än något fördröjd, datakälla.Exempel B: C4illin/systembolaget-data: Detta projekt är ett annat tydligt exempel på en lösning som uttryckligen skapats som en ersättning för det officiella API:et. Det tillhandahåller en enda, massiv JSON-fil (cirka 73 MB) som innehåller alla produkter. Projektet erbjuder även en Docker-konfiguration för enkel driftsättning.Strategi 2: Omvänd ingenjörskonst (Reverse-Engineering) av interna API:erEn mer tekniskt avancerad och bräcklig metod är att analysera nätverkstrafiken på Systembolagets egen webbplats för att identifiera och använda de privata, interna API:er som webbplatsens frontend använder för att driva sin sökfunktion.Exempel: dcronqvist/systembolaget-api 1: Detta projekt är ett fascinerande exempel på denna metod. Utvecklaren identifierade den interna slutpunkten för produktsökning (https://api-extern.systembolaget.se/sb-api-ecommerce/v1/productsearch) samt den nödvändiga API-nyckeln (cfc702aed3094c86b92d6d4ff7a54c84) genom att inspektera webbläsarens nätverksanrop. Skriptet fungerade genom att först hämta en lista över alla butiker och sedan systematiskt anropa den interna slutpunkten för varje butik för att bygga en komplett produktdatabas.Bedömning av livskraft och riskEn kritisk upptäckt i denna analys är statusen för dessa olika tillvägagångssätt. Projektet dcronqvist/systembolaget-api, som använder omvänd ingenjörskonst, är för närvarande inaktivt. Projektets dokumentation anger tydligt att API:et "inte är tillgängligt för tillfället" i väntan på kommunikation med Systembolaget angående eventuella brott mot deras användarvillkor.1 Detta gör denna metod icke-livskraftig för omedelbar implementering och belyser den inneboende risken med att förlita sig på oofficiella, interna system som kan ändras eller blockeras när som helst.Slutsatsen är därför att strategin med statiska datarepositorier är den mest pålitliga och stabila vägen framåt. Denna metod är mindre sårbar för förändringar på Systembolagets webbplats och utgör inte ett lika direkt brott mot användarvillkoren som att använda en extraherad API-nyckel. Denna beroendeställning till tredjepartsarkiv är en medveten risk, men stabiliteten hos projekt som AlexGustafssons gör den till en acceptabel kompromiss.1.3 Datadjupdykning för vinentusiastenEfter att ha identifierat en pålitlig datakälla är nästa avgörande fråga: är datan tillräckligt detaljerad för att tillfredsställa en "vin-nörd"? Svaret är ett rungande ja. Den data som finns tillgänglig i de rekommenderade statiska arkiven är exceptionellt rik och detaljerad, vilket gör den perfekt lämpad för avancerad filtrering och analys.Genom att analysera datastrukturen i en exempelfil som data/assortment.json från AlexGustafssons arkiv, kan vi identifiera ett flertal fält som är av särskilt intresse för en vinentusiast.Tabell 1: Nyckelfält för vindata i de inofficiella datamängdernaFältnamnExempelvärdeBeskrivning och betydelse för en vinentusiastproductNameBold"Barolo"Huvudnamnet på produkten. Ofta det mest kända namnet eller varumärket.productNameThin"Fontanafredda"Tilläggsnamn, ofta producenten. Tillsammans med productNameBold ger det en komplett identifikation.vintage"2018"Årgången för vinet. En av de mest kritiska parametrarna för att bedöma ett vins karaktär och kvalitet.alcoholPercentage14.5Alkoholhalt i procent. En viktig indikator på vinets stil och kropp.volumeText"750 ml"Flaskans storlek. Standard för de flesta viner men viktigt för att identifiera halvflaskor eller magnum.price329Pris i svenska kronor. En grundläggande parameter för sökning och filtrering.country"Italien"Ursprungsland. Den bredaste geografiska klassificeringen.originLevel1"Piemonte"Huvudregion inom landet. Avgörande för att söka efter viner från specifika, kända områden som Bordeaux, Toscana eller Napa Valley.originLevel2"Barolo"Underregion eller appellation. Ger en ännu högre detaljnivå, vilket möjliggör sökning på specifika DOCG- eller AOC-områden.grapes["Nebbiolo"]En lista med druvsorter. Kanske det viktigaste fältet för en vinentusiast, möjliggör sökning efter specifika druvor eller blandningar.taste"Nyanserad, kryddig smak med fatkaraktär, inslag av torkade körsbär, nypon, kanel, rosor, kakao och ceder."En detaljerad, textbaserad smakbeskrivning. Ovärderlig för att förstå vinets karaktär och för att AI:n ska kunna ge nyanserade rekommendationer.tasteClockBody10En numerisk skala (1-12) för fyllighet. Ger kvantitativ data för att filtrera på lätta, medelfylliga eller fylliga viner.tasteClockRoughness10En numerisk skala (1-12) för strävhet (tanniner). Kritiskt för att hitta viner som passar personliga preferenser eller specifika maträtter.tasteClockSweetness1En numerisk skala (1-12) för sötma. Avgörande för att skilja mellan torra, halvtorra och söta viner.tasteClockFruitacid10En numerisk skala (1-12) för fruktsyra. En viktig komponent i vinets struktur och lagringspotential.assortmentText"Fast sortiment"Anger vilken del av sortimentet vinet tillhör (t.ex. fast, tillfälligt, beställning). Viktigt för att förstå tillgänglighet.Denna detaljrikedom bekräftar att datagrunden är mer än tillräcklig för att bygga ett kraftfullt och nyanserat sök- och rekommendationsverktyg. Möjligheten att kombinera filter som druvsort, specifik appellation, årgång och smakprofiler (via smakklockorna) lägger grunden för en verkligt expertanpassad upplevelse.Sektion 2: Arkitektoniska vägar för AI-integrationFör att en AI-modell som Claude ska kunna interagera med och resonera kring extern data, såsom den från Systembolagets sortiment, krävs en mekanism som kallas "Tool Use" eller "Function Calling". Detta innebär att man definierar en uppsättning verktyg (funktioner eller API-slutpunkter) som AI:n kan anropa för att hämta information som den inte har i sin interna kunskapsbas. AI:n analyserar användarens fråga, identifierar när ett verktyg behövs, formulerar ett anrop till verktyget med relevanta parametrar och använder sedan resultatet för att formulera sitt slutgiltiga svar.Valet av arkitektur för att implementera detta verktyg är ett avgörande beslut som påverkar allt från säkerhet och prestanda till användarupplevelse och framtida underhåll. Två huvudsakliga vägar presenteras här, var och en representerar en distinkt teknisk strategi.Väg A: Webbtjänstmodellen. Detta är den traditionella och universellt kompatibla metoden. Den innebär att man bygger en liten, personlig webbserver som agerar som en mellanhand. Denna server läser in den lokala vindatan (JSON-filen) och exponerar den via ett standardiserat REST API. Claude interagerar sedan med detta API över internet, precis som den skulle göra med vilken annan offentlig webbtjänst som helst.Väg B: Den lokala MCP-servermodellen. Detta är en mer modern och djupt integrerad metod som är specifikt anpassad för användarens miljö: Claude Desktop. Denna väg innebär att man bygger en lokal server som kommunicerar direkt med Claude Desktop-applikationen på samma dator via Model Context Protocol (MCP). Detta skapar en säker, snabb och sömlös koppling utan att data någonsin behöver lämna användarens lokala maskin.Valet mellan dessa två vägar är ett val mellan universell kompatibilitet och en optimerad, lokal-först-upplevelse. Följande sektioner kommer att detaljera implementeringen och konsekvenserna av varje väg för att ge ett gediget beslutsunderlag.Sektion 3: Väg A - En webbtjänst med standardiserad Claude Tool Use (Function Calling)Denna arkitektur representerar den mest etablerade metoden för att integrera externa datakällor med stora språkmodeller. Den bygger på välkända teknologier som webbservrar och REST API:er, vilket gör den konceptuellt enkel att förstå och implementera.3.1 Konceptuell arkitekturFlödet i denna modell är linjärt och bygger på en serie anrop mellan de olika komponenterna.Flödesdiagram:Användarfråga -> Claude (via Anthropic API) -> Claude identifierar behov av verktyg -> API-anrop till personlig webbtjänst -> Webbtjänsten söker i lokal data (JSON-fil) -> JSON-svar till Claude-applikationen -> Applikationen skickar tillbaka resultatet till Claude (via Anthropic API) -> Claude genererar ett svar i naturligt språk -> Svar till användaren.Komponenter:Datalager: Den nedladdade assortment.json-filen från ett av de rekommenderade community-arkiven. För bättre prestanda vid upprepade sökningar kan denna data med fördel laddas in i en enkel, filbaserad databas som SQLite vid serverstart.Webbserver: En lättviktig webbserver skriven i ett språk som Python (med ramverket Flask) eller Node.js (med Express). Serverns enda uppgift är att ladda in datan och exponera en eller flera API-slutpunkter, till exempel /search_wines, som kan ta emot sökparametrar och returnera en lista med matchande viner.Claude-integration: En applikation (t.ex. ett Python-skript) som hanterar interaktionen med Anthropics Messages API. Denna applikation ansvarar för att definiera verktyget för Claude, skicka användarens fråga, tolka Claudes begäran om att använda verktyget, utföra API-anropet till den egna webbservern och skicka tillbaka resultatet till Claude.3.2 ImplementeringsguideNedan följer en konceptuell guide för att implementera denna arkitektur med Python och Flask.Steg 1: Sätta upp data och serverFörst skapas en enkel Flask-server som läser in assortment.json och skapar en sök-slutpunkt.Konceptuell Python/Flask-kod:Pythonfrom flask import Flask, request, jsonify
import json

app = Flask(__name__)

# Ladda in hela sortimentet i minnet vid start
with open('assortment.json', 'r', encoding='utf-8') as f:
    wine_data = json.load(f)

@app.route('/search_wines', methods=)
def search_wines():
    # Hämta sökparametrar från URL:en
    # Exempel: /search_wines?country=Italien&max_price=200
    params = request.args
    
    results = wine_data
    
    # Filtrera datan baserat på mottagna parametrar
    if 'country' in params:
        results = [wine for wine in results if wine.get('country') == params['country']]
    if 'max_price' in params:
        results = [wine for wine in results if wine.get('price', 0) <= float(params['max_price'])]
    #... lägg till fler filter för druvor, region, etc.
    
    return jsonify(results)

if __name__ == '__main__':
    app.run(port=5001)
Steg 2: Definiera verktyget för ClaudeI applikationen som kommunicerar med Claude definieras verktyget get_wines med en tydlig beskrivning och ett detaljerat input_schema. Detta schema är avgörande för att Claude ska förstå vilka parametrar som är tillgängliga och hur de ska formateras.Konceptuell Python-kod för API-anrop:Pythonimport anthropic

client = anthropic.Anthropic(api_key="YOUR_ANTHROPIC_API_KEY")

get_wines_tool = {
    "name": "get_wines",
    "description": "Söker efter viner i Systembolagets sortiment baserat på olika kriterier som land, druva, pris och smakprofil.",
    "input_schema": {
        "type": "object",
        "properties": {
            "country": {"type": "string", "description": "Ursprungsland, t.ex. 'Italien'"},
            "grapes": {"type": "array", "items": {"type": "string"}, "description": "En lista med druvsorter, t.ex."},
            "min_price": {"type": "number", "description": "Lägsta pris i SEK"},
            "max_price": {"type": "number", "description": "Högsta pris i SEK"},
            "taste_clock_body_min": {"type": "number", "description": "Minsta fyllighet på en skala 1-12"}
        },
    }
}
Steg 3: Det konversationella flödet (The "Tool Use Loop")Detta är den centrala interaktionscykeln mellan applikationen och Claude.Användarförfrågan: Användaren skriver: "Hitta ett fylligt italienskt rött vin under 200 kr gjort på Sangiovese-druvan."Claudes första svar (begäran om verktygsanvändning): Applikationen skickar frågan till Claude tillsammans med verktygsdefinitionen. Claudes API svarar inte med en text, utan med ett svarsobjekt där stop_reason är satt till "tool_use". Svarets content kommer att innehålla en begäran om att anropa verktyget get_wines med parametrar som Claude har extraherat från frågan, t.ex. {"country": "Italien", "grapes":, "max_price": 200, "taste_clock_body_min": 8}.Applikationen exekverar verktyget: Koden i applikationen tar emot denna begäran. Den gör nu ett faktiskt HTTP GET-anrop till den lokala Flask-servern: http://localhost:5001/search_wines?country=Italien&.... Servern svarar med en JSON-lista över matchande viner.Resultatet skickas tillbaka till Claude: Applikationen gör ett andra anrop till Anthropics API. Denna gång inkluderar den hela den föregående konversationshistoriken, plus ett nytt meddelande som innehåller resultatet från verktygsanropet.Claudes slutgiltiga svar: Claude tar emot listan med viner, analyserar den i kontexten av den ursprungliga frågan och formulerar ett slutgiltigt, sammanfattande svar i naturligt språk, t.ex. "Jag har hittat tre utmärkta italienska viner på Sangiovese under 200 kr som matchar din beskrivning. Ett bra val skulle kunna vara..."Denna arkitektur är kraftfull och flexibel. Den är inte bunden till Claude Desktop och skulle fungera i vilken miljö som helst där man kan köra en webbserver och anropa Anthropics API. Den medför dock vissa nackdelar. Att köra en webbserver, även lokalt, kan innebära säkerhetsrisker om den inte konfigureras korrekt (t.ex. om en port öppnas i brandväggen). Dessutom kräver den hantering av två separata processer (AI-applikationen och webbservern) och nätverkskommunikation mellan dem, vilket kan addera en viss komplexitet.Sektion 4: Väg B - Djup integration via en lokal MCP-server (Den rekommenderade metoden)Denna väg representerar en mer modern och specialiserad arkitektur som är skräddarsydd för att skapa djupt integrerade, lokala verktyg för AI-applikationer som Claude Desktop. Den utnyttjar Model Context Protocol (MCP) för att skapa en direkt, säker och effektiv kommunikationskanal mellan AI-assistenten och det lokala verktyget.4.1 Model Context Protocol (MCP) förklaratMCP är ett öppet protokoll, utvecklat av Anthropic, som standardiserar hur AI-applikationer ansluter till externa datakällor och verktyg. Det beskrivs ofta med analogin "USB-C-porten för AI". Precis som USB-C erbjuder en standardiserad anslutning för en mängd olika enheter, erbjuder MCP ett enhetligt sätt för AI-modeller att interagera med olika verktyg, oavsett om de körs lokalt eller på en fjärrserver.Arkitekturen bygger på en klient-server-modell. I detta projekt agerar Claude Desktop som MCP-klient, medan det vin-sökverktyg som byggs agerar som MCP-server. Kommunikationen sker lokalt på datorn, vilket ger flera avgörande fördelar för detta specifika användningsfall:Lokal-först och privat: Servern och all data (vin-sortimentet) stannar på användarens maskin. Ingen information behöver skickas över internet till en extern tjänst (förutom kommunikationen med Claudes egen backend), vilket garanterar maximal integritet och säkerhet.Sömlös integration: När MCP-servern är konfigurerad dyker dess verktyg automatiskt upp i Claude Desktops användargränssnitt. Detta skapar en mycket mer "inbyggd" och sammanhängande upplevelse jämfört med att interagera med en separat webbtjänst.Användarkontroll och säkerhet: En kärnfunktion i MCP-integrationen i Claude Desktop är att användaren alltid måste ge sitt explicita godkännande innan ett verktyg får utföra en åtgärd. En dialogruta visas som tydligt anger vilket verktyg som vill köras och med vilka parametrar, vilket säkerställer att användaren alltid har full kontroll.24.2 Implementeringsguide: Bygga MCP-servernFör att bygga MCP-servern rekommenderas TypeScript och Node.js på grund av det utmärkta officiella SDK:t och de tillgängliga verktygen som förenklar utvecklingen avsevärt.Steg 1: Projekt-setupDet enklaste sättet att starta är att använda det officiella kommandoradsverktyget för att skapa ett nytt serverprojekt. Detta skapar en komplett projektstruktur med all nödvändig grundkod.Bash# Kör detta i din terminal
npx @modelcontextprotocol/create-server mitt-vin-verktyg
Detta kommando skapar en ny mapp mitt-vin-verktyg med ett färdigt TypeScript-projekt. Andra boilerplate-projekt finns också tillgängliga för referens.Steg 2: Definiera verktygenInuti det nyskapade projektet (specifikt i filen src/index.ts) definieras de verktyg som servern ska erbjuda. Detta görs genom att implementera en hanterare för ListToolsRequestSchema. Definitionen liknar den i Väg A, med ett namn, en beskrivning och ett inputSchema som specificerar parametrarna.Konceptuell TypeScript-kod:TypeScript// Inom serverns setup-logik
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools:,
  };
});
Steg 3: Implementera verktygslogikenSjälva söklogiken implementeras i hanteraren för CallToolRequestSchema. Det är här servern tar emot parametrarna från Claude, läser och filtrerar assortment.json-filen och returnerar resultatet i det format som MCP-protokollet kräver.Konceptuell TypeScript-kod:TypeScriptserver.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === 'search_wines') {
    const args = request.params.arguments as { country?: string; max_price?: number; /*... */ };
    
    // Läs in och filtrera wine_data.json baserat på 'args'
    const results = performWineSearch(args); // Egen sökfunktion

    return {
      tool_outputs: [{
        tool_name: 'search_wines',
        output: {
          content: [{ type: 'json', json: results }]
        }
      }]
    };
  }
  //... hantera fel om verktyget inte finns
});
Steg 4: Köra servernEfter att koden är skriven kompileras den och körs lokalt.Bash# Kompilera TypeScript till JavaScript
npm run build

# Starta servern
npm start
Servern är nu igång och lyssnar på stdin för instruktioner från en MCP-klient som Claude Desktop.4.3 Konfigurera Claude DesktopDet sista steget är att tala om för Claude Desktop att den här nya MCP-servern existerar och hur den ska startas. Detta görs i en central konfigurationsfil.2claude_desktop_config.json-filen:Denna JSON-fil är hjärtat i Claude Desktops anpassningsmöjligheter. Här specificeras alla lokala MCP-servrar som applikationen ska hantera.Plats för filen:macOS: ~/Library/Application Support/Claude/claude_desktop_config.jsonWindows: %APPDATA%\Claude\claude_desktop_config.jsonKonfigurations-snippet:Följande JSON-objekt läggs till i filen under nyckeln mcpServers. Det är viktigt att args pekar på den absoluta sökvägen till den kompilerade serverfilen (dist/index.js).JSON{
  "mcpServers": {
    "vin-verktyg": {
      "command": "node",
      "args": [
        "/Users/ditt-anvandarnamn/sokvag/till/mitt-vin-verktyg/dist/index.js"
      ]
    }
  }
}
Detta instruerar Claude Desktop att när den startar, ska den också starta en process med kommandot node och ge den sökvägen till server-skriptet som argument.Omstart och verifiering:Efter att ha sparat konfigurationsfilen måste Claude Desktop startas om helt. Om allt är korrekt konfigurerat kommer en ny ikon (ofta en hammare eller reglage) att dyka upp i inmatningsfältet. Genom att klicka på denna ikon kan man se att det nya verktyget, search_wines, nu är tillgängligt för Claude.4.4 Den integrerade användarupplevelsenMed denna konfiguration blir arbetsflödet anmärkningsvärt smidigt.Användaren skriver samma fråga som tidigare direkt i Claude Desktops chattfönster.Claude analyserar frågan och förstår att det lokala verktyget search_wines kan användas för att besvara den.En dialogruta visas direkt i Claude Desktops gränssnitt. Den frågar om tillåtelse att köra search_wines och visar de parametrar som Claude har extraherat (t.ex. land: "Italien", max_price: 200).Användaren klickar på "Allow".Claude Desktop skickar kommandot till den lokala MCP-servern, som exekverar sökningen och returnerar resultaten.Resultaten matas direkt tillbaka till Claude, som sedan genererar det slutgiltiga, välformulerade svaret i samma chattfönster.Denna arkitektur är överlägsen för det specifika målet att bygga ett personligt verktyg för Claude Desktop. Den är säkrare, snabbare och erbjuder en betydligt bättre användarupplevelse. Genom att lära sig bygga en MCP-server får användaren dessutom en kraftfull färdighet som kan återanvändas för att bygga andra lokala verktyg, som att interagera med det lokala filsystemet, databaser eller andra applikationer.Sektion 5: Strategiska rekommendationer och framtidsutsikterEfter en detaljerad genomgång av de två arkitektoniska vägarna är det dags att väga deras respektive för- och nackdelar mot varandra för att kunna ge en tydlig och välgrundad rekommendation.5.1 Jämförande analys av arkitekturernaFör att underlätta beslutet presenteras en jämförelse baserad på flera kriterier som är relevanta för projektets mål och användarens kontext.Tabell 2: Jämförelse av integrationsvägar (Webb-API vs. MCP-server)KriteriumVäg A (Webb-API + Tool Use)Väg B (Lokal MCP-server)Enkelhet i setupMåttlig. Kräver kunskap om webbserver-ramverk (t.ex. Flask) och hantering av HTTP-anrop. Två separata processer att hantera.Måttlig. Kräver förståelse för MCP SDK och konfiguration av en JSON-fil. Officiella verktyg förenklar dock processen avsevärt.Säkerhet & integritetGodtagbar. Kräver potentiellt att en nätverksport öppnas, vilket kan innebära en säkerhetsrisk om det inte hanteras korrekt.Utmärkt. Helt lokal kommunikation. Data lämnar aldrig användarens dator. Ingen nätverksexponering krävs.PrestandaBra. Prestandan begränsas av nätverkslatensen för lokala HTTP-anrop, vilket vanligtvis är försumbart.Utmärkt. Kommunikation sker via standard I/O (stdio), vilket är extremt snabbt och har minimal overhead.AnvändarupplevelseBra. Funktionellt, men interaktionen är helt kod-driven. Saknar visuell integration i Claude Desktop.Utmärkt. Sömlös integration i Claude Desktops gränssnitt med inbyggda dialogrutor för godkännande, vilket ger en "inbyggd" känsla.UnderhållMåttlig. Kräver underhåll av två separata kodbaser (server och klient-applikation).Bra. All logik är samlad i en enda MCP-server. Claude Desktop hanterar klient-sidan.UtbyggbarhetBra. Lätt att lägga till nya API-slutpunkter. Universellt kompatibel med andra system som kan göra HTTP-anrop.Utmärkt. Mycket enkelt att lägga till nya verktyg till samma MCP-server. Främjar skapandet av ett ekosystem av lokala verktyg.Anpassning till användarens intresseLåg. Använder en generell metod som inte är specifik för Claude Desktop eller MCP.Hög. Motsvarar direkt användarens uttryckta intresse för att utforska MCP och Claude Desktops avancerade funktioner.5.2 Den rekommenderade vägen framåt: Omfamna Model Context ProtocolBaserat på den jämförande analysen är rekommendationen entydig: Väg B, att bygga en lokal MCP-server, är den överlägset bästa metoden för detta projekt.Motivering:Denna rekommendation vilar på flera starka argument som direkt härrör från analysen. För ett personligt verktyg där integritet och säkerhet är av yttersta vikt, är MCP-arkitekturens lokala natur oslagbar. Den eliminerar helt de nätverks- och säkerhetsöverväganden som är förknippade med en webbtjänst. Användarupplevelsen är markant bättre tack vare den djupa integrationen i Claude Desktop, vilket gör att verktyget känns som en naturlig del av AI-assistenten snarare än en extern tjänst. Slutligen är denna väg direkt i linje med användarens uttryckta nyfikenhet på MCP, vilket gör projektet inte bara till ett sätt att bygga ett verktyg, utan också en möjlighet att lära sig en banbrytande teknologi för AI-integration. Det är den mest eleganta, robusta och framtidssäkra lösningen för detta specifika användningsfall.5.3 Avancerat ämne: Paketering som en Desktop Extension (.dxt)För att ta projektet till en ännu högre nivå av professionalitet och användarvänlighet, finns det ett sista, valfritt steg: att paketera den färdiga MCP-servern som en "Desktop Extension" (.dxt-fil).3 Detta är den moderna distributionsmetoden för MCP-servrar som Anthropic har introducerat för att lösa många av de långsiktiga utmaningarna med manuell konfiguration.Fördelar med .dxt-paketering:Bärbarhet: En .dxt-fil är ett självförsörjande paket. Den innehåller inte bara serverkoden utan även alla dess beroenden, inklusive en specifik version av Node.js-runtime. Detta innebär att verktyget enkelt kan installeras på en annan dator (eller ominstalleras på samma) utan att man behöver oroa sig för att installera Node.js eller andra paket manuellt.Enkel installation: Istället för att manuellt redigera en JSON-konfigurationsfil, installeras en .dxt-fil med ett enkelt dubbelklick. Claude Desktop hanterar resten.Användarvänlig konfiguration: Istället för att hårdkoda sökvägen till assortment.json i serverkoden, kan en .dxt-fil definiera att den behöver en sökväg från användaren. Claude Desktop kommer då att presentera en grafisk dialogruta vid installationen där användaren kan välja fil, vilket gör verktyget mycket mer flexibelt och användarvänligt.Processöversikt:Processen att skapa en .dxt-fil är relativt enkel. Den innefattar att skapa en manifest.json-fil som beskriver servern, dess beroenden och eventuella användarkonfigurationer. Därefter används ett kommandoradsverktyg (dxt pack) för att paketera allt till en enda arkivfil.3 Att ta detta extra steg förvandlar ett fungerande projekt till en polerad, återanvändbar och lättdistribuerad personlig applikation.SlutsatsSammanfattning av rönDenna strategiska och tekniska guide har navigerat landskapet för att bygga ett AI-drivet vinutforskningsverktyg. De centrala upptäckterna är tydliga: trots att Systembolagets officiella produkt-API har stängts, existerar ett rikt och livskraftigt ekosystem av community-drivna datakällor. Den tillgängliga datan är av exceptionellt hög kvalitet och detaljrikedom, fullt kapabel att tillfredsställa även den mest kräsne vinentusiasten. För att koppla denna data till Claude Desktop har två arkitektoniska vägar analyserats, där Model Context Protocol (MCP) framstår som den tekniskt överlägsna och mest ändamålsenliga lösningen.Bemyndigande och slutlig uppmuntranProjektets genomförbarhet är bortom allt tvivel. Med den rekommenderade metoden och de detaljerade stegen som beskrivits, är användaren nu utrustad med en komplett strategisk och teknisk blåkopia. Denna guide tillhandahåller all nödvändig information för att bygga ett kraftfullt, personligt och säkert vinutforskningsverktyg som är djupt integrerat med den valda AI-assistenten. Resan från att vara en "vin-nörd" till att bli skaparen av en skräddarsydd AI-sommelier är tydligt utstakad och redo att påbörjas.